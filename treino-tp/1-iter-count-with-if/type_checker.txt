void udf::type_checker::do_iterate_node(udf::iterate_node * const node, int lvl) {
  
  node->vector()->accept(this, lvl);
  node->count()->accept(this, lvl);
  node->condition()->accept(this, lvl);

  if(node->count()->is_typed(cdk::TYPE_UNSPEC)) {
    node->count()->type(cdk::primitive_type::create(4, cdk::TYPE_INT));
  } else if (!node->count()->is_typed(cdk::TYPE_INT)) {
    throw std::string("Count must be integer!");
  }

  if(node->condition()->is_typed(cdk::TYPE_UNSPEC)) {
    node->condition()->type(cdk::primitive_type::create(4, cdk::TYPE_INT));
  } else if (!node->condition()->is_typed(cdk::TYPE_INT)) {
    throw std::string("Condition must be integer!");
  }

  if(!node->vector()->is_typed(cdk::TYPE_POINTER)) {
    throw std::string("Vector must be a pointer!");
  }

  auto symbol = _symtab.find(node->identifier());

  if(!symbol) {
    throw std::string("Function identifier not found!");
  }

  if(!symbol->isFunction()) {
    throw std::string("Identifier must be a function identifier!");
  }

  if(symbol->number_of_arguments() != 1) {
    throw std::string("Function must have one input value!");
  }

  auto referenceType = cdk::reference_type::cast(node->vector()->type())->referenced();
  if(!symbol->argument_is_typed(0, referenceType->name())) {
    throw std::string("Function input value and vector values type dont match!");
  }
}
